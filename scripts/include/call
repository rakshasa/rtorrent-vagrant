#!/bin/bash

DEBUG=${DEBUG:-0}

SCRIPT_DIR=`dirname $( dirname ${BASH_SOURCE[0]} )`
ROOT_DIR="${SCRIPT_DIR}/../"
DATA_DIR="${ROOT_DIR}/data/"
TEST_DIR="${ROOT_DIR}/test/"

RPC_CLIENT="${SCRIPT_DIR}/xmlrpc2scgi.py"

DATA_VM_TORRENTS="/data/torrents/"
DATA_HOST_WATCH="${DATA_DIR}/shared/watch/"

TORRENT_VM_DIR="/data/torrents/"
TORRENT_SHARED_DIR="${DATA_DIR}/shared/torrents/"

GIT_RTORRENT="${DATA_DIR}/builder/rtorrent/"
GIT_LIBTORRENT="${DATA_DIR}/builder/libtorrent/"

NC='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'

if [ -z "${NODES}" ]; then
    NODES="$((cd ${DATA_DIR} && ls -d node*) 2> /dev/null)"
fi

call_ssh_nodes() {
    for node in ${NODES[@]}; do
        echo "${node}: $@"
        ${SCRIPT_DIR}/ssh "${node}" $@
    done
}

call_ssh_nodes_p() {
    printf '%s\n' ${NODES[@]} | xargs -n 1 -P 8 -I{} "${SCRIPT_DIR}/ssh" {} $@
}

call_ssh_nodes_s() {
    SLEEP_TIMER="0"

    for node in ${NODES[@]}; do
        sleep ${SLEEP_TIMER}

        echo "${node}: $@"
        ${SCRIPT_DIR}/ssh "${node}" $@

        SLEEP_TIMER="2"
    done
}

call_rpc() {
    FORWARD_PORT=`cat ${DATA_DIR}/${CALL_NODE:?Missing node argument.}/metadata/forward.5001`

    if [ -z ${FORWARD_PORT} ]; then
        >&2 echo "Could not find forward port for ${CALL_NODE}"
        exit -1
    fi

    NODE_URL="scgi://localhost:${FORWARD_PORT}"
    CALL_CMD="${RPC_CLIENT} -s ${NODE_URL} $@"

    [ "${DEBUG}" == "1" ] && >&2 echo "${CALL_CMD}"

    ${CALL_CMD}
}

call_rpc_nodes() {
    for CALL_NODE in ${NODES[@]}; do
        echo "${CALL_NODE}:"
        call_rpc $@
    done
}

call_rpc_awk_nodes() {
    for CALL_NODE in ${NODES[@]}; do
        echo "${CALL_NODE}:"
        call_rpc $@ | awk -f "${SCRIPT_DIR}/include/${AWK_FILE}.awk"
    done
}

wait_for_nodes() {
    SECONDS=0

    local timeout="${WAIT_TIMEOUT:-30}"
    local nodes="${WAIT_NODES:-${NODES}}"
    local method="$1"
    shift

    #echo "wait_for_node: ${remaining} calling '${method}' $i $@"

    while true; do
        local check="${nodes[@]}"
        local failed=

        for node in ${check[@]}; do
            #if "${SCRIPT_DIR}/${method}" "${node}" $@ &> /dev/null; then
            if "${SCRIPT_DIR}/${method}" "${node}" $@; then
                [ "${DEBUG}" == "1" ] && >&2 echo "wait_for_nodes done: ${SCRIPT_DIR}/${method} ${node} $@"
            else
                [ "${DEBUG}" == "1" ] && >&2 echo "wait_for_nodes failed: ${SCRIPT_DIR}/${method} ${node} $@"
                failed+="${node} "
            fi
        done

        if [ -z "${failed[@]}" ]; then
            return 0
        fi

        if (( SECONDS > timeout )); then
            >&2 echo "could not verify ${method} for nodes: ${failed[@]}"
            >&2 echo "failed ${method} with arguments: $@"
            return 1
        fi

        echo "----"
        echo "${failed[@]}"
        echo ${SECONDS}
        echo ${timeout}
        echo "----" 

        sleep 0.5
    done
}

#
# Helper functions.
#

extra_rc_command_padding() {
    local name="${1:?Missing command name.}"
    (tail -n 1 "${DATA_DIR}/${NODE}/config/extra.rc" | grep -e "^${name}") &> /dev/null || (echo >> "${DATA_DIR}/${NODE}/config/extra.rc")
}

